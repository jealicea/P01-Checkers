/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/CheckersGame.js":
/*!*****************************!*\
  !*** ./src/CheckersGame.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CheckersGame: () => (/* binding */ CheckersGame)\n/* harmony export */ });\n// CheckersGame.js\n// Logic for Checkers\n\nclass CheckersGame {\n\n    constructor() {\n        this.board = null;\n        this.currentPlayer = null;\n        this.selectedPiece = null;\n        this.validMoves = [];\n        this.isGameOver = false;\n\n        this.reset();\n    }\n\n    /**\n     * Resets the game to the initial state.\n     */\n    reset() {\n        this.board = this.createBoard();\n        this.currentPlayer = 'red';\n        this.selectedPiece = null;\n        this.validMoves = [];\n        this.isGameOver = false;\n    }\n\n    /**\n     * Create the initial board setup.\n     * @returns {Array} The initial board state.\n     */\n    createBoard() {\n        const board = [];\n        for (let row = 0; row < 8; row++) {\n            const newRow = [];\n            for (let col = 0; col < 8; col++) {\n                if (row < 3 && (row + col) % 2 === 1) {\n                    newRow.push({ color: 'black', player: 'black', isKing: false });\n                } else if (row > 4 && (row + col) % 2 === 1) {\n                    newRow.push({ color: 'red', player: 'red', isKing: false });\n                } else {\n                    newRow.push(null);\n                }\n            }\n            board.push(newRow);\n        }\n        return board;\n    }\n\n    /**\n     * Select a piece on the board.\n     * @param {number} row \n     * @param {number} col \n     * @returns {boolean} Whether the selection was successful.\n     */\n    selectPiece(row, col) {\n        const piece = this.board[row][col];\n        if (!piece) return false;\n\n        if (piece.color === this.currentPlayer) {\n            this.selectedPiece = { row, col };\n            this.validMoves = this.getValidMoves(row, col);\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Deselect the currently selected piece.\n     */\n    deselectPiece() {\n        this.selectedPiece = null;\n        this.validMoves = [];\n    }\n\n\n    /** \n     * Get valid moves for a piece at (row, col).\n     * @param {number} row \n     * @param {number} col \n     * @returns {Array} List of valid move positions.\n     */\n    getValidMoves(row, col) {\n        const piece = this.board[row][col];\n        if (!piece) return [];\n\n        const moves = [];\n        const directions = [];\n\n        if (piece.isKing) {\n            directions.push(\n                { rowDirection: -1, colDirection: -1 }, { rowDirection: -1, colDirection: 1 },\n                { rowDirection: 1, colDirection: -1 }, { rowDirection: 1, colDirection: 1 }\n            );\n        } else {\n            if (piece.color === 'red') {\n                directions.push({ rowDirection: -1, colDirection: -1 }, { rowDirection: -1, colDirection: 1 });\n            }\n            if (piece.color === 'black') {\n                directions.push({ rowDirection: 1, colDirection: -1 }, { rowDirection: 1, colDirection: 1 });\n            }\n        }\n\n        for (const { rowDirection, colDirection } of directions) {\n            const newRow = row + rowDirection; \n            const newCol = col + colDirection;\n            // Normal move\n            if (this.isOnBoard(newRow, newCol) && !this.board[newRow][newCol]) {\n                moves.push({ row: newRow, col: newCol });\n            }\n            // Capture move\n            const jumpRow = row + 2 * rowDirection;\n            const jumpCol = col + 2 * colDirection;\n            if (this.isOnBoard(jumpRow, jumpCol) &&\n                !this.board[jumpRow][jumpCol] &&\n                this.board[newRow][newCol] &&\n                this.board[newRow][newCol].color !== piece.color) {\n                moves.push({ row: jumpRow, col: jumpCol, capture: { row: newRow, col: newCol } });\n            }\n        }\n        return moves;\n    }\n\n    /**\n     * Make a move for the selected piece.\n     * @param {number} row \n     * @param {number} col \n     * @returns {boolean} Whether the move was successful.\n     */\n    makeMove(row, col) {\n        if (!this.selectedPiece) return false;\n        const move = this.validMoves.find(m => m.row === row && m.col === col); // Find the move in validMoves\n        if (!move) return false; \n\n        const { row: fromRow, col: fromCol } = this.selectedPiece;\n        const piece = this.board[fromRow][fromCol];\n\n        // Move piece\n        this.board[fromRow][fromCol] = null;\n        this.board[row][col] = piece;\n\n        // Handle a capture\n        if (move.capture) {\n            this.board[move.capture.row][move.capture.col] = null;\n        }\n\n        // Turn piece into king\n        if ((piece.color === 'red' && row === 0) || (piece.color === 'black' && row === 7)) {\n            piece.isKing = true;\n        }\n\n        this.deselectPiece();\n        this.switchPlayer();\n        return true;\n\n    }\n\n    /**\n     * Switch the current player.\n     */\n    switchPlayer() {\n        this.currentPlayer = this.currentPlayer === 'red' ? 'black' : 'red';\n    }\n\n    /**\n     * Check if the position is on the board.\n     * @param {number} row the row index\n     * @param {number} col the column index\n     * @returns {boolean} true if the position is on the board, false otherwise\n     */\n    isOnBoard(row, col) {\n        return row >= 0 && row < 8 && col >= 0 && col < 8;\n    }\n}\n\n\n//# sourceURL=webpack://checkers-game/./src/CheckersGame.js?\n}");

/***/ }),

/***/ "./src/checkers3d.js":
/*!***************************!*\
  !*** ./src/checkers3d.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _CheckersGame_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CheckersGame.js */ \"./src/CheckersGame.js\");\n// Three.js Simple Table\n\n\nlet scene, camera, renderer, controls;\nlet game; // CheckersGame instance\nlet boardSquares = []; // Store references to board squares\nlet pieces = []; // Store references to piece meshes\nlet raycaster, mouse; // For mouse interaction\nlet selectedSquareMaterial, validMoveMaterial; // Materials for highlighting\n\nfunction init() {\n    // Initialize game logic\n    game = new _CheckersGame_js__WEBPACK_IMPORTED_MODULE_0__.CheckersGame();\n\n    // Initialize mouse interaction\n    raycaster = new THREE.Raycaster();\n    mouse = new THREE.Vector2();\n\n    // Create materials for highlighting\n    selectedSquareMaterial = new THREE.MeshLambertMaterial({ color: 0x00ff00, transparent: true, opacity: 0.5 });\n    validMoveMaterial = new THREE.MeshLambertMaterial({ color: 0x0080ff, transparent: true, opacity: 0.3 });\n\n    // Create scene\n    scene = new THREE.Scene();\n    scene.background = new THREE.Color(0xf0f0f0);\n\n    // Create camera\n    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);\n    camera.position.set(8, 6, 8);\n\n    // Create renderer\n    renderer = new THREE.WebGLRenderer({ antialias: true });\n    renderer.setSize(window.innerWidth, window.innerHeight - 100); // Account for header/button\n    renderer.shadowMap.enabled = true;\n    renderer.shadowMap.type = THREE.PCFSoftShadowMap;\n    document.body.appendChild(renderer.domElement);\n\n    // Create orbit controls for mouse interaction\n    controls = new THREE.OrbitControls(camera, renderer.domElement);\n    controls.enableDamping = true; // Smooth camera movement\n    controls.dampingFactor = 0.05;\n    controls.screenSpacePanning = false;\n    controls.minDistance = 3; // Minimum zoom distance\n    controls.maxDistance = 50; // Maximum zoom distance\n    controls.maxPolarAngle = Math.PI / 2; // Prevent camera from going below the ground\n\n    // Create simple table\n    createSimpleTable();\n\n    // Add checkers board\n    createCheckersBoard();\n\n    // Add checkers pieces\n    createCheckersPieces();\n\n    // Add lighting\n    addLighting();\n\n    // Add mouse click event listener\n    renderer.domElement.addEventListener('click', onMouseClick, false);\n\n    // Initialize board highlighting\n    updateBoardHighlighting();\n    updateGameStatus();\n\n    // Start animation loop\n    animate();\n\n    // Handle window resize\n    window.addEventListener('resize', onWindowResize, false);\n}\n\nfunction createSimpleTable() {\n    // Square table top (now acts as the floor) - made bigger\n    const tableTopGeometry = new THREE.BoxGeometry(8, 0.2, 8);\n    const tableTopMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 }); // Brown color\n    const tableTop = new THREE.Mesh(tableTopGeometry, tableTopMaterial);\n    tableTop.position.y = 0; // Place at ground level\n    tableTop.castShadow = true;\n    tableTop.receiveShadow = true;\n    scene.add(tableTop);\n\n    // Table legs (4 legs) - now extend downward from the table surface, positioned for bigger table\n    const legGeometry = new THREE.BoxGeometry(0.2, 1.5, 0.2);\n    const legMaterial = new THREE.MeshLambertMaterial({ color: 0x654321 }); // Darker brown\n\n    // Front left leg\n    const leg1 = new THREE.Mesh(legGeometry, legMaterial);\n    leg1.position.set(-3.6, -0.75, 3.6);\n    leg1.castShadow = true;\n    scene.add(leg1);\n\n    // Front right leg\n    const leg2 = new THREE.Mesh(legGeometry, legMaterial);\n    leg2.position.set(3.6, -0.75, 3.6);\n    leg2.castShadow = true;\n    scene.add(leg2);\n\n    // Back left leg\n    const leg3 = new THREE.Mesh(legGeometry, legMaterial);\n    leg3.position.set(-3.6, -0.75, -3.6);\n    leg3.castShadow = true;\n    scene.add(leg3);\n\n    // Back right leg\n    const leg4 = new THREE.Mesh(legGeometry, legMaterial);\n    leg4.position.set(3.6, -0.75, -3.6);\n    leg4.castShadow = true;\n    scene.add(leg4);\n}\n\nfunction createCheckersBoard() {\n    const squareSize = 0.9; // Size of each square\n    const boardSize = 8; // 8x8 board\n    const boardOffset = (boardSize - 1) * squareSize / 2; // Center the board\n\n    // Initialize boardSquares array\n    boardSquares = [];\n    for (let row = 0; row < boardSize; row++) {\n        boardSquares[row] = [];\n    }\n\n    // Materials for light and dark squares - matching checkers2d.js colors\n    const lightSquareMaterial = new THREE.MeshLambertMaterial({ color: 0xf0d9b5 }); // Light beige\n    const darkSquareMaterial = new THREE.MeshLambertMaterial({ color: 0xb58863 }); // Darker brown\n\n    for (let row = 0; row < boardSize; row++) {\n        for (let col = 0; col < boardSize; col++) {\n            // Determine if square should be light or dark\n            const isLightSquare = (row + col) % 2 === 0;\n            \n            // Create square geometry\n            const squareGeometry = new THREE.BoxGeometry(squareSize, 0.05, squareSize);\n            const squareMaterial = isLightSquare ? lightSquareMaterial : darkSquareMaterial;\n            const square = new THREE.Mesh(squareGeometry, squareMaterial);\n            \n            // Position the square\n            const x = (col * squareSize) - boardOffset;\n            const z = (row * squareSize) - boardOffset;\n            square.position.set(x, 0.125, z); // Slightly above table surface\n            \n            // Store reference to square with board position\n            square.userData = { row, col, originalMaterial: squareMaterial };\n            boardSquares[row][col] = square;\n            \n            square.castShadow = true;\n            square.receiveShadow = true;\n            scene.add(square);\n        }\n    }\n}\n\nfunction createCheckersPieces() {\n    // Clear existing pieces\n    clearPieces();\n\n    const squareSize = 0.9;\n    const boardSize = 8; // 8x8 board\n    const boardOffset = (boardSize - 1) * squareSize / 2;\n    const pieceRadius = 0.35;\n    const pieceHeight = 0.1;\n\n    // Initialize pieces array\n    pieces = [];\n    for (let row = 0; row < boardSize; row++) {\n        pieces[row] = [];\n        for (let col = 0; col < boardSize; col++) {\n            pieces[row][col] = null;\n        }\n    }\n\n    // Materials for pieces - matching checkers2d.html colors\n    const redPieceMaterial = new THREE.MeshLambertMaterial({ color: 0xdc3545 }); // Red pieces\n    const blackPieceMaterial = new THREE.MeshLambertMaterial({ color: 0x343a40 }); // Black pieces\n    const redKingMaterial = new THREE.MeshLambertMaterial({ color: 0xff6b7a }); // Lighter red for kings\n    const blackKingMaterial = new THREE.MeshLambertMaterial({ color: 0x6c757d }); // Lighter black for kings\n\n    // Create piece geometry (cylinder for round pieces)\n    const pieceGeometry = new THREE.CylinderGeometry(pieceRadius, pieceRadius, pieceHeight, 16);\n\n    // Create pieces based on game state\n    for (let row = 0; row < boardSize; row++) {\n        for (let col = 0; col < boardSize; col++) {\n            const gamepiece = game.board[row][col];\n            if (gamepiece) {\n                let material;\n                if (gamepiece.isKing) {\n                    material = gamepiece.color === 'red' ? redKingMaterial : blackKingMaterial;\n                } else {\n                    material = gamepiece.color === 'red' ? redPieceMaterial : blackPieceMaterial;\n                }\n\n                const piece = new THREE.Mesh(pieceGeometry, material);\n                \n                // Position the piece\n                const x = (col * squareSize) - boardOffset;\n                const z = (row * squareSize) - boardOffset;\n                piece.position.set(x, 0.2, z); // Above the board squares\n                \n                // Store piece data\n                piece.userData = { row, col, color: gamepiece.color, isKing: gamepiece.isKing };\n                pieces[row][col] = piece;\n                \n                piece.castShadow = true;\n                piece.receiveShadow = true;\n                scene.add(piece);\n            }\n        }\n    }\n}\n\nfunction addLighting() {\n    // Ambient light\n    const ambientLight = new THREE.AmbientLight(0x404040, 0.3);\n    scene.add(ambientLight);\n\n    // Directional light (sun-like)\n    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);\n    directionalLight.position.set(10, 10, 5);\n    directionalLight.castShadow = true;\n    directionalLight.shadow.mapSize.width = 2048;\n    directionalLight.shadow.mapSize.height = 2048;\n    scene.add(directionalLight);\n}\n\nfunction animate() {\n    requestAnimationFrame(animate);\n    \n    // Update controls for smooth interaction\n    controls.update();\n    \n    renderer.render(scene, camera);\n}\n\nfunction onWindowResize() {\n    camera.aspect = window.innerWidth / window.innerHeight;\n    camera.updateProjectionMatrix();\n    renderer.setSize(window.innerWidth, window.innerHeight - 100);\n}\n\n/**\n * Clear all pieces from the scene\n */\nfunction clearPieces() {\n    if (pieces) {\n        for (let row = 0; row < pieces.length; row++) {\n            for (let col = 0; col < pieces[row].length; col++) {\n                if (pieces[row][col]) {\n                    scene.remove(pieces[row][col]);\n                    pieces[row][col] = null;\n                }\n            }\n        }\n    }\n}\n\n/**\n * Update game status display\n */\nfunction updateGameStatus() {\n    const statusElement = document.getElementById('gameStatus');\n    if (statusElement) {\n        const currentPlayerName = game.currentPlayer.charAt(0).toUpperCase() + game.currentPlayer.slice(1);\n        statusElement.textContent = `Current Player: ${currentPlayerName}`;\n        statusElement.style.color = game.currentPlayer === 'red' ? '#dc3545' : '#343a40';\n    }\n}\n\n/**\n * Update board square highlighting based on game state\n */\nfunction updateBoardHighlighting() {\n    // Reset all squares to original material\n    for (let row = 0; row < 8; row++) {\n        for (let col = 0; col < 8; col++) {\n            const square = boardSquares[row][col];\n            if (square) {\n                square.material = square.userData.originalMaterial;\n            }\n        }\n    }\n\n    // Highlight selected piece square\n    if (game.selectedPiece) {\n        const { row, col } = game.selectedPiece;\n        const square = boardSquares[row][col];\n        if (square) {\n            square.material = selectedSquareMaterial;\n        }\n    }\n\n    // Highlight valid move squares\n    game.validMoves.forEach(move => {\n        const square = boardSquares[move.row][move.col];\n        if (square) {\n            square.material = validMoveMaterial;\n        }\n    });\n}\n\n/**\n * Handle mouse clicks for piece selection and movement\n */\nfunction onMouseClick(event) {\n    // Prevent camera controls from interfering\n    event.preventDefault();\n\n    // Calculate mouse position in normalized device coordinates (-1 to +1)\n    const rect = renderer.domElement.getBoundingClientRect();\n    mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;\n    mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;\n\n    // Update the picking ray with the camera and mouse position\n    raycaster.setFromCamera(mouse, camera);\n\n    // Calculate objects intersecting the picking ray\n    const intersects = raycaster.intersectObjects(scene.children);\n\n    if (intersects.length > 0) {\n        const intersected = intersects[0].object;\n        \n        // Check if clicked on a board square\n        if (intersected.userData && typeof intersected.userData.row !== 'undefined') {\n            const { row, col } = intersected.userData;\n            handleSquareClick(row, col);\n        }\n    }\n}\n\n/**\n * Handle click on a board square - similar to checkers2d.js logic\n */\nfunction handleSquareClick(row, col) {\n    if (game.isGameOver) return;\n    \n    // Try to select piece or make move\n    if (!game.selectPiece(row, col) && !game.makeMove(row, col)) {\n        game.deselectPiece();\n    }\n    \n    // Update visual representation\n    updateBoardHighlighting();\n    updatePieces();\n    updateGameStatus();\n}\n\n/**\n * Update pieces visual representation to match game state\n */\nfunction updatePieces() {\n    createCheckersPieces(); // Recreate all pieces based on current game state\n}\n\n/**\n * Reset the game and visual representation\n */\nfunction resetGame() {\n    game.reset();\n    createCheckersPieces(); // This will recreate all pieces in their original positions\n    updateBoardHighlighting();\n    updateGameStatus();\n    \n    // Reset camera position\n    camera.position.set(8, 6, 8);\n    controls.target.set(0, 0, 0);\n    controls.update();\n}\n\n// Initialize when the page loads\nwindow.addEventListener('load', init);\n\n// Reset button functionality\ndocument.getElementById('resetButton3D').addEventListener('click', function () {\n    resetGame();\n});\n\n\n//# sourceURL=webpack://checkers-game/./src/checkers3d.js?\n}");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/checkers3d.js");
/******/ 	
/******/ })()
;